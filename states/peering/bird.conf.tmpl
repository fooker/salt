### This file is managed by saltstack - any changes will be overwritten ###

router id {{ pillar.peering.peers[grains.id].router_id }};

protocol device {
	scan time 10;
}

table output;

protocol kernel output_kernel {
	persist;
	learn;

	table output;
	import none;
	export all;
}

{% for domain in pillar.peering.peers[grains.id].domains|sort -%}
table {{ domain }};

protocol direct {{ domain }}_direct {
	interface "{{ domain }}";
	check link yes;

	table {{ domain }};
	import all;
	export none;
}

{% if 'ospf' in pillar.peering.domains[domain] and 'ospf' in pillar.peering.peers[grains.id].protos %}
protocol ospf {{ domain }}_ospf {
	instance id {{ pillar.peering.domains[domain].ospf.instance_id }};

	area 0 {
		{%- for peer in pillar.peering.transfers[grains.id]|sort if 'ospf' in pillar.peering.peers[peer].protos and domain in pillar.peering.peers[peer].domains %}
		interface "peer.{{ pillar.peering.peers[peer].netdev }}" {
			type pointopoint;

			check link on;
		};
		{%- endfor %}
	};

	table {{ domain }};
	import keep filtered;
	import filter {
		if net ~ [{{ pillar.peering.interfaces[grains.id][domain].ip4.network }}/{{ pillar.peering.interfaces[grains.id][domain].ip4.netmask }}+] then reject;

		if net ~ [
			{%- for export in pillar.peering.domains[domain].exports.ip4|sort %}
			{{ export }}+
			{%- endfor %}
		] then accept;

		if net ~ [
			{%- for filter in pillar.peering.domains[domain].filters.ip4|sort %}
			{{ filter }}
			{%- if not loop.last -%},{%- endif %}
			{%- endfor %}
		] then accept;

		reject;
	};
	export filter {
		if net ~ [
			{%- for export in pillar.peering.domains[domain].exports.ip4|sort %}
			{{ export }}+
			{%- endfor %}
		] then accept;

		if net ~ [
			{%- for filter in pillar.peering.domains[domain].filters.ip4|sort %}
			{{ filter }}
			{%- if not loop.last -%},{%- endif %}
			{%- endfor %}
		] then accept;

		reject;
	};
}
{% endif %}

{% if 'bgp' in pillar.peering.domains[domain] and ('bgp' in pillar.peering.peers[grains.id].protos or 'ibgp' in pillar.peering.peers[grains.id].protos) %}
table {{ domain }}_egp;

protocol static {{ domain }}_static {
	{%- for export in pillar.peering.domains[domain].exports.ip4|sort %}
	route {{ export }} via "{{ domain }}";
	{%- endfor %}

	table {{ domain }}_egp;
	import all;
	export none;
}

template bgp {{ domain }}_bgp {
	local as {{ pillar.peering.domains[domain].bgp.as }};

	path metric 1;

	next hop self;
	check link on;

	direct;

	table {{ domain }}_egp;
	import keep filtered;
	import limit 1000 action block;
	import filter {
		if net ~ [{{ pillar.peering.interfaces[grains.id][domain].ip4.network }}/{{ pillar.peering.interfaces[grains.id][domain].ip4.netmask }}+] then reject;

		if net ~ [
			{%- for export in pillar.peering.domains[domain].exports.ip4|sort %}
			{{ export }}+
			{%- endfor %}
		] then reject;

		if net ~ [
			{%- for filter in pillar.peering.domains[domain].filters.ip4|sort %}
			{{ filter }}
			{%- if not loop.last -%},{%- endif %}
			{%- endfor %}
		] then accept;

		reject;
	};
	export filter {
		if net ~ [
			{%- for export in pillar.peering.domains[domain].exports.ip4|sort %}
			{{ export }}+
			{%- endfor %}
		] then accept;

		if net ~ [
			{%- for filter in pillar.peering.domains[domain].filters.ip4|sort %}
			{{ filter }}
			{%- if not loop.last -%},{%- endif %}
			{%- endfor %}
		] then accept;

		reject;
	};
}

{% for peer in pillar.peering.transfers[grains.id]|sort if 'bgp' in pillar.peering.peers[peer].protos and domain in pillar.peering.peers[peer].domains %}
protocol bgp {{ domain }}_bgp_{{ pillar.peering.peers[peer].netdev | replace('.', '_') }} from {{ domain }}_bgp {
	neighbor {{ pillar.peering.transfers[grains.id][peer].ip4.remote }} as {{ pillar.peering.peers[peer].as }};
}
{% endfor %}

{% for peer in pillar.peering.transfers[grains.id]|sort if 'ibgp' in pillar.peering.peers[peer].protos and domain in pillar.peering.peers[peer].domains %}
protocol bgp {{ domain }}_bgp_{{ pillar.peering.peers[peer].netdev | replace('.', '_') }} from {{ domain }}_bgp {
	neighbor {{ pillar.peering.transfers[grains.id][peer].ip4.remote }} as {{ pillar.peering.domains[domain].bgp.as }};
}
{% endfor %}

protocol pipe {{ domain }}_egp_pipe {
	table {{ domain }}_egp;

	import none;
	export all;

	peer table {{ domain }};
}
{% endif %}

protocol pipe {{ domain }}_pipe {
	table {{ domain }};
	import none;
	export filter {
		krt_prefsrc = {{ pillar.peering.interfaces[grains.id][domain].ip4.address }};
		if net ~ [{{ pillar.peering.interfaces[grains.id][domain].ip4.network }}/{{ pillar.peering.interfaces[grains.id][domain].ip4.netmask }}+] then reject;

		accept;
	};

	peer table output;
}

{% endfor -%}

